{"ast":null,"code":"import { useRef, useEffect, useState, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport observeRect from '@reach/observe-rect';\nimport { isBoolean, isFunction, warning, useIsomorphicLayoutEffect } from '@reach/utils';\n/**\r\n * Welcome to @reach/rect!\r\n *\r\n * Measures DOM elements (aka. bounding client rect).\r\n *\r\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\r\n * @see Docs                  https://reach.tech/rect\r\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\r\n */\n\n/**\r\n * Rect\r\n *\r\n * @param props\r\n */\n\nvar Rect = function Rect(_ref) {\n  var onChange = _ref.onChange,\n      _ref$observe = _ref.observe,\n      observe = _ref$observe === void 0 ? true : _ref$observe,\n      children = _ref.children;\n  var ref = useRef(null);\n  var rect = useRect(ref, {\n    observe: observe,\n    onChange: onChange\n  });\n  return children({\n    ref: ref,\n    rect: rect\n  });\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func\n  };\n}\n/**\r\n * useRect\r\n *\r\n * @param nodeRef\r\n * @param observe\r\n * @param onChange\r\n */\n\n\nfunction useRect(nodeRef, observeOrOptions, deprecated_onChange) {\n  var observe;\n  var onChange;\n\n  if (isBoolean(observeOrOptions)) {\n    observe = observeOrOptions;\n  } else {\n    var _observeOrOptions$obs;\n\n    observe = (_observeOrOptions$obs = observeOrOptions === null || observeOrOptions === void 0 ? void 0 : observeOrOptions.observe) !== null && _observeOrOptions$obs !== void 0 ? _observeOrOptions$obs : true;\n    onChange = observeOrOptions === null || observeOrOptions === void 0 ? void 0 : observeOrOptions.onChange;\n  }\n\n  if (isFunction(deprecated_onChange)) {\n    onChange = deprecated_onChange;\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(function () {\n      process.env.NODE_ENV !== \"production\" ? warning(!isBoolean(observeOrOptions), \"Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\\n\" + \"See https://reach.tech/rect#userect-observe\") : void 0;\n    }, [observeOrOptions]); // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    useEffect(function () {\n      process.env.NODE_ENV !== \"production\" ? warning(!isFunction(deprecated_onChange), \"Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\\n\" + \"See https://reach.tech/rect#userect-onchange\") : void 0;\n    }, [deprecated_onChange]);\n  }\n\n  var _React$useState = useState(nodeRef.current),\n      element = _React$useState[0],\n      setElement = _React$useState[1];\n\n  var initialRectIsSet = useRef(false);\n  var initialRefIsSet = useRef(false);\n\n  var _React$useState2 = useState(null),\n      rect = _React$useState2[0],\n      setRect = _React$useState2[1];\n\n  var onChangeRef = useRef(onChange);\n  var stableOnChange = useCallback(function (rect) {\n    onChangeRef.current && onChangeRef.current(rect);\n  }, []); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  useIsomorphicLayoutEffect(function () {\n    onChangeRef.current = onChange;\n\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n  useIsomorphicLayoutEffect(function () {\n    var observer;\n    var elem = element; // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn(\"You need to place the ref\");\n      }\n\n      return cleanup;\n    }\n\n    observer = observeRect(elem, function (rect) {\n      stableOnChange(rect);\n      setRect(rect);\n    });\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element, nodeRef, stableOnChange]);\n  return rect;\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nexport default Rect;\nexport { Rect, useRect };","map":{"version":3,"sources":["../src/index.tsx"],"names":["Rect","onChange","observe","children","ref","React","rect","useRect","PropTypes","func","isBoolean","observeOrOptions","isFunction","element","setElement","nodeRef","initialRectIsSet","initialRefIsSet","setRect","onChangeRef","stableOnChange","useLayoutEffect","elem","console","observer","observeRect"],"mappings":"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","sourcesContent":["/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reach.tech/rect\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\n */\n\nimport * as React from \"react\";\nimport PropTypes from \"prop-types\";\nimport observeRect from \"@reach/observe-rect\";\nimport {\n  isBoolean,\n  isFunction,\n  useIsomorphicLayoutEffect as useLayoutEffect,\n  warning,\n} from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Rect\n *\n * @param props\n */\nconst Rect: React.FC<RectProps> = ({ onChange, observe = true, children }) => {\n  const ref = React.useRef<HTMLElement | null>(null);\n  const rect = useRect(ref, { observe, onChange });\n  return children({ ref, rect });\n};\n\n/**\n * @see Docs https://reach.tech/rect#rect-props\n */\ntype RectProps = UseRectOptions & {\n  /**\n   * A function that calls back to you with a `ref` to place on an element and\n   * the `rect` measurements of the dom node.\n   *\n   * **Note**: On the first render `rect` will be `undefined` because we can't\n   * measure a node that has not yet been rendered. Make sure your code accounts\n   * for this.\n   *\n   * @see Docs https://reach.tech/rect#rect-onchange\n   */\n  children(args: {\n    rect: PRect | null;\n    ref: React.RefObject<any>;\n  }): JSX.Element;\n};\n\nif (__DEV__) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  options?: UseRectOptions\n): null | DOMRect;\n\nfunction useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observe?: UseRectOptions[\"observe\"],\n  onChange?: UseRectOptions[\"onChange\"]\n): null | DOMRect;\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nfunction useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observeOrOptions?: boolean | UseRectOptions,\n  deprecated_onChange?: UseRectOptions[\"onChange\"]\n): null | DOMRect {\n  let observe: boolean;\n  let onChange: UseRectOptions[\"onChange\"];\n  if (isBoolean(observeOrOptions)) {\n    observe = observeOrOptions;\n  } else {\n    observe = observeOrOptions?.observe ?? true;\n    onChange = observeOrOptions?.onChange;\n  }\n  if (isFunction(deprecated_onChange)) {\n    onChange = deprecated_onChange;\n  }\n\n  if (__DEV__) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      warning(\n        !isBoolean(observeOrOptions),\n        \"Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\\n\" +\n          \"See https://reach.tech/rect#userect-observe\"\n      );\n    }, [observeOrOptions]);\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      warning(\n        !isFunction(deprecated_onChange),\n        \"Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\\n\" +\n          \"See https://reach.tech/rect#userect-onchange\"\n      );\n    }, [deprecated_onChange]);\n  }\n\n  let [element, setElement] = React.useState(nodeRef.current);\n  let initialRectIsSet = React.useRef(false);\n  let initialRefIsSet = React.useRef(false);\n  let [rect, setRect] = React.useState<DOMRect | null>(null);\n  let onChangeRef = React.useRef(onChange);\n  let stableOnChange = React.useCallback((rect: PRect) => {\n    onChangeRef.current && onChangeRef.current(rect);\n  }, []);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useLayoutEffect(() => {\n    onChangeRef.current = onChange;\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n\n  useLayoutEffect(() => {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n\n  useLayoutEffect(() => {\n    let observer: ReturnType<typeof observeRect>;\n    let elem = element;\n\n    // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (__DEV__) {\n        console.warn(\"You need to place the ref\");\n      }\n      return cleanup;\n    }\n\n    observer = observeRect(elem, (rect) => {\n      stableOnChange(rect);\n      setRect(rect);\n    });\n\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element, nodeRef, stableOnChange]);\n\n  return rect;\n}\n\n/**\n * @see Docs https://reach.tech/rect#userect\n */\ntype UseRectOptions = {\n  /**\n   * Tells `Rect` to observe the position of the node or not. While observing,\n   * the `children` render prop may call back very quickly (especially while\n   * scrolling) so it can be important for performance to avoid observing when\n   * you don't need to.\n   *\n   * This is typically used for elements that pop over other elements (like a\n   * dropdown menu), so you don't need to observe all the time, only when the\n   * popup is active.\n   *\n   * Pass `true` to observe, `false` to ignore.\n   *\n   * @see Docs https://reach.tech/rect#userect-observe\n   */\n  observe?: boolean;\n  /**\n   * Calls back whenever the `rect` of the element changes.\n   *\n   * @see Docs https://reach.tech/rect#userect-onchange\n   */\n  onChange?: (rect: PRect) => void;\n};\n\ntype PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Exports\n\nexport default Rect;\nexport type { PRect, UseRectOptions, RectProps };\nexport { Rect, useRect };\n"]},"metadata":{},"sourceType":"module"}