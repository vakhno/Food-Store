{"version":3,"file":"popover.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/popover!\n */\n\nimport * as React from \"react\";\nimport { Portal } from \"@reach/portal\";\nimport { useRect, PRect } from \"@reach/rect\";\nimport { forwardRefWithAs, getOwnerDocument, useForkedRef } from \"@reach/utils\";\nimport tabbable from \"tabbable\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Popover\n */\nconst Popover = forwardRefWithAs<PopoverProps, \"div\">(function Popover(\n  props,\n  ref\n) {\n  return (\n    <Portal>\n      <PopoverImpl ref={ref} {...props} />\n    </Portal>\n  );\n});\n\ntype PopoverProps = {\n  children: React.ReactNode;\n  targetRef: React.RefObject<HTMLElement>;\n  position?: Position;\n  /**\n   * Render the popover markup, but hide it â€“ used by MenuButton so that it\n   * can have an `aria-controls` attribute even when its menu isn't open, and\n   * used inside `Popover` as a hint that we can tell `useRect` to stop\n   * observing for better performance.\n   */\n  hidden?: boolean;\n  /**\n   * Testing this API so we might accept additional nodes that apps can use to\n   * determine the position of the popover. One example where it may be useful\n   * is for positioning the popover of a listbox where the cursor rests on top\n   * of the selected option. Pretty sure this will change so don't use it\n   * anywhere in public yet!\n   */\n  unstable_observableRefs?: React.RefObject<PossibleNode>[];\n};\n\nif (__DEV__) {\n  Popover.displayName = \"Popover\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * PopoverImpl\n *\n * Popover is conditionally rendered so we can't start measuring until it shows\n * up, so useRect needs to live down here not up in Popover\n */\nconst PopoverImpl = forwardRefWithAs<PopoverProps, \"div\">(function PopoverImpl(\n  {\n    as: Comp = \"div\",\n    targetRef,\n    position = positionDefault,\n    unstable_observableRefs = [],\n    ...props\n  },\n  forwardedRef\n) {\n  const popoverRef = React.useRef<HTMLDivElement>(null);\n  const popoverRect = useRect(popoverRef, { observe: !props.hidden });\n  const targetRect = useRect(targetRef, { observe: !props.hidden });\n  const ref = useForkedRef(popoverRef, forwardedRef);\n\n  useSimulateTabNavigationForReactTree(targetRef, popoverRef);\n\n  return (\n    <Comp\n      data-reach-popover=\"\"\n      ref={ref}\n      {...props}\n      style={{\n        position: \"absolute\",\n        ...getStyles(\n          position,\n          targetRect,\n          popoverRect,\n          ...unstable_observableRefs\n        ),\n        ...props.style,\n      }}\n    />\n  );\n});\n\nif (__DEV__) {\n  PopoverImpl.displayName = \"PopoverImpl\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction getStyles(\n  position: Position,\n  targetRect: PRect | null,\n  popoverRect: PRect | null,\n  ...unstable_observableRefs: React.RefObject<PossibleNode>[]\n): React.CSSProperties {\n  return popoverRect\n    ? position(\n        targetRect,\n        popoverRect,\n        ...unstable_observableRefs.map((ref) => ref.current)\n      )\n    : { visibility: \"hidden\" };\n}\n\nfunction getTopPosition(targetRect: PRect, popoverRect: PRect) {\n  const { directionUp } = getCollisions(targetRect, popoverRect);\n  return {\n    top: directionUp\n      ? `${targetRect.top - popoverRect.height + window.pageYOffset}px`\n      : `${targetRect.top + targetRect.height + window.pageYOffset}px`,\n  };\n}\n\nconst positionDefault: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  const { directionRight } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionRight\n      ? `${targetRect.right - popoverRect.width + window.pageXOffset}px`\n      : `${targetRect.left + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nconst positionRight: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  const { directionLeft } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionLeft\n      ? `${targetRect.left + window.pageXOffset}px`\n      : `${targetRect.right - popoverRect.width + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nconst positionMatchWidth: Position = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n\n  return {\n    width: targetRect.width,\n    left: targetRect.left,\n    ...getTopPosition(targetRect, popoverRect),\n  };\n};\n\nfunction getCollisions(\n  targetRect: PRect,\n  popoverRect: PRect,\n  offsetLeft: number = 0,\n  offsetBottom: number = 0\n) {\n  const collisions = {\n    top: targetRect.top - popoverRect.height < 0,\n    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,\n    bottom:\n      window.innerHeight <\n      targetRect.bottom + popoverRect.height - offsetBottom,\n    left: targetRect.left + targetRect.width - popoverRect.width < 0,\n  };\n\n  const directionRight = collisions.right && !collisions.left;\n  const directionLeft = collisions.left && !collisions.right;\n  const directionUp = collisions.bottom && !collisions.top;\n  const directionDown = collisions.top && !collisions.bottom;\n\n  return { directionRight, directionLeft, directionUp, directionDown };\n}\n\n// Heads up, my jQuery past haunts this function. This hook scopes the tab\n// order to the React element tree, instead of the DOM tree. This way, when the\n// user navigates with tab from the targetRef, the tab order moves into the\n// popup, and then out of the popup back to the rest of the document.\n// (We call targetRef, triggerRef inside this function to avoid confusion with\n// event.target)\nfunction useSimulateTabNavigationForReactTree<\n  T extends HTMLElement,\n  P extends HTMLElement\n>(triggerRef: React.RefObject<T>, popoverRef: React.RefObject<P>) {\n  const ownerDocument = getOwnerDocument(triggerRef.current)!;\n\n  function handleKeyDown(event: KeyboardEvent) {\n    if (\n      event.key === \"Tab\" &&\n      popoverRef.current &&\n      tabbable(popoverRef.current).length === 0\n    ) {\n      return;\n    }\n\n    if (event.key === \"Tab\" && event.shiftKey) {\n      if (shiftTabbedFromElementAfterTrigger(event)) {\n        focusLastTabbableInPopover(event);\n      } else if (shiftTabbedOutOfPopover(event)) {\n        focusTriggerRef(event);\n      } else if (shiftTabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    } else if (event.key === \"Tab\") {\n      if (tabbedFromTriggerToPopover()) {\n        focusFirstPopoverTabbable(event);\n      } else if (tabbedOutOfPopover()) {\n        focusTabbableAfterTrigger(event);\n      } else if (tabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    }\n  }\n\n  React.useEffect(() => {\n    ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n    return () => {\n      ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  function getElementAfterTrigger() {\n    const elements = tabbable(ownerDocument);\n    const targetIndex =\n      elements && triggerRef.current\n        ? elements.indexOf(triggerRef.current)\n        : -1;\n    const elementAfterTrigger = elements && elements[targetIndex + 1];\n    return popoverRef.current &&\n      popoverRef.current.contains(elementAfterTrigger || null)\n      ? false\n      : elementAfterTrigger;\n  }\n\n  function tabbedFromTriggerToPopover() {\n    return triggerRef.current\n      ? triggerRef.current === ownerDocument.activeElement\n      : false;\n  }\n\n  function focusFirstPopoverTabbable(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements && elements[0]) {\n      event.preventDefault();\n      elements[0].focus();\n    }\n  }\n\n  function tabbedOutOfPopover() {\n    const inPopover = popoverRef.current\n      ? popoverRef.current.contains(ownerDocument.activeElement || null)\n      : false;\n    if (inPopover) {\n      const elements = popoverRef.current && tabbable(popoverRef.current);\n      return Boolean(\n        elements &&\n          elements[elements.length - 1] === ownerDocument.activeElement\n      );\n    }\n    return false;\n  }\n\n  function focusTabbableAfterTrigger(event: KeyboardEvent) {\n    const elementAfterTrigger = getElementAfterTrigger();\n    if (elementAfterTrigger) {\n      event.preventDefault();\n      elementAfterTrigger.focus();\n    }\n  }\n\n  function shiftTabbedFromElementAfterTrigger(event: KeyboardEvent) {\n    if (!event.shiftKey) return;\n    const elementAfterTrigger = getElementAfterTrigger();\n    return event.target === elementAfterTrigger;\n  }\n\n  function focusLastTabbableInPopover(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    const last = elements && elements[elements.length - 1];\n    if (last) {\n      event.preventDefault();\n      last.focus();\n    }\n  }\n\n  function shiftTabbedOutOfPopover(event: KeyboardEvent) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      return elements.length === 0 ? false : event.target === elements[0];\n    }\n    return false;\n  }\n\n  function focusTriggerRef(event: KeyboardEvent) {\n    event.preventDefault();\n    triggerRef.current?.focus();\n  }\n\n  function tabbedToBrowserChrome(event: KeyboardEvent) {\n    const elements = popoverRef.current\n      ? tabbable(ownerDocument).filter(\n          (element) => !popoverRef.current!.contains(element)\n        )\n      : null;\n    return elements ? event.target === elements[elements.length - 1] : false;\n  }\n\n  function shiftTabbedToBrowserChrome(event: KeyboardEvent) {\n    // we're assuming the popover will never contain the first tabbable\n    // element, and it better not, because the trigger needs to be tabbable!\n    return event.target === tabbable(ownerDocument)[0];\n  }\n\n  let restoreTabIndexTuplÃ©s: [HTMLElement, number][] = [];\n\n  function disableTabbablesInPopover() {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      elements.forEach((element) => {\n        restoreTabIndexTuplÃ©s.push([element, element.tabIndex]);\n        element.tabIndex = -1;\n      });\n      ownerDocument.addEventListener(\"focusin\", enableTabbablesInPopover);\n    }\n  }\n\n  function enableTabbablesInPopover() {\n    ownerDocument.removeEventListener(\"focusin\", enableTabbablesInPopover);\n    restoreTabIndexTuplÃ©s.forEach(([element, tabIndex]) => {\n      element.tabIndex = tabIndex;\n    });\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype Position = (\n  targetRect?: PRect | null,\n  popoverRect?: PRect | null,\n  ...unstable_observableNodes: PossibleNode[]\n) => React.CSSProperties;\n\ntype PossibleNode = null | undefined | HTMLElement | SVGElement;\n\n////////////////////////////////////////////////////////////////////////////////\n// Exports\n\nexport default Popover;\nexport type { PopoverProps, Position };\nexport {\n  getCollisions,\n  Popover,\n  positionDefault,\n  positionMatchWidth,\n  positionRight,\n};\n"],"names":["Popover","forwardRefWithAs","props","ref","React","Portal","PopoverImpl","forwardedRef","as","Comp","targetRef","position","positionDefault","unstable_observableRefs","popoverRef","popoverRect","useRect","observe","hidden","targetRect","useForkedRef","triggerRef","ownerDocument","getOwnerDocument","current","handleKeyDown","event","key","tabbable","length","shiftKey","elementAfterTrigger","getElementAfterTrigger","target","shiftTabbedFromElementAfterTrigger","elements","last","preventDefault","focus","focusLastTabbableInPopover","shiftTabbedOutOfPopover","focusTriggerRef","shiftTabbedToBrowserChrome","disableTabbablesInPopover","activeElement","focusFirstPopoverTabbable","contains","Boolean","tabbedOutOfPopover","focusTabbableAfterTrigger","filter","element","tabbedToBrowserChrome","targetIndex","indexOf","addEventListener","removeEventListener","restoreTabIndexTuplÃ©s","forEach","push","tabIndex","enableTabbablesInPopover","useSimulateTabNavigationForReactTree","style","getStyles","map","visibility","getTopPosition","top","getCollisions","directionUp","height","window","pageYOffset","left","directionRight","right","width","pageXOffset","offsetLeft","offsetBottom","collisions","innerWidth","bottom","innerHeight","directionLeft","directionDown"],"mappings":"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"}