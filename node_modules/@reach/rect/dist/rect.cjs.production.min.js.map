{"version":3,"file":"rect.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reach.tech/rect\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\n */\n\nimport * as React from \"react\";\nimport PropTypes from \"prop-types\";\nimport observeRect from \"@reach/observe-rect\";\nimport {\n  isBoolean,\n  isFunction,\n  useIsomorphicLayoutEffect as useLayoutEffect,\n  warning,\n} from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Rect\n *\n * @param props\n */\nconst Rect: React.FC<RectProps> = ({ onChange, observe = true, children }) => {\n  const ref = React.useRef<HTMLElement | null>(null);\n  const rect = useRect(ref, { observe, onChange });\n  return children({ ref, rect });\n};\n\n/**\n * @see Docs https://reach.tech/rect#rect-props\n */\ntype RectProps = UseRectOptions & {\n  /**\n   * A function that calls back to you with a `ref` to place on an element and\n   * the `rect` measurements of the dom node.\n   *\n   * **Note**: On the first render `rect` will be `undefined` because we can't\n   * measure a node that has not yet been rendered. Make sure your code accounts\n   * for this.\n   *\n   * @see Docs https://reach.tech/rect#rect-onchange\n   */\n  children(args: {\n    rect: PRect | null;\n    ref: React.RefObject<any>;\n  }): JSX.Element;\n};\n\nif (__DEV__) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  options?: UseRectOptions\n): null | DOMRect;\n\nfunction useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observe?: UseRectOptions[\"observe\"],\n  onChange?: UseRectOptions[\"onChange\"]\n): null | DOMRect;\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nfunction useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observeOrOptions?: boolean | UseRectOptions,\n  deprecated_onChange?: UseRectOptions[\"onChange\"]\n): null | DOMRect {\n  let observe: boolean;\n  let onChange: UseRectOptions[\"onChange\"];\n  if (isBoolean(observeOrOptions)) {\n    observe = observeOrOptions;\n  } else {\n    observe = observeOrOptions?.observe ?? true;\n    onChange = observeOrOptions?.onChange;\n  }\n  if (isFunction(deprecated_onChange)) {\n    onChange = deprecated_onChange;\n  }\n\n  if (__DEV__) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      warning(\n        !isBoolean(observeOrOptions),\n        \"Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\\n\" +\n          \"See https://reach.tech/rect#userect-observe\"\n      );\n    }, [observeOrOptions]);\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      warning(\n        !isFunction(deprecated_onChange),\n        \"Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\\n\" +\n          \"See https://reach.tech/rect#userect-onchange\"\n      );\n    }, [deprecated_onChange]);\n  }\n\n  let [element, setElement] = React.useState(nodeRef.current);\n  let initialRectIsSet = React.useRef(false);\n  let initialRefIsSet = React.useRef(false);\n  let [rect, setRect] = React.useState<DOMRect | null>(null);\n  let onChangeRef = React.useRef(onChange);\n  let stableOnChange = React.useCallback((rect: PRect) => {\n    onChangeRef.current && onChangeRef.current(rect);\n  }, []);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useLayoutEffect(() => {\n    onChangeRef.current = onChange;\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n\n  useLayoutEffect(() => {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n\n  useLayoutEffect(() => {\n    let observer: ReturnType<typeof observeRect>;\n    let elem = element;\n\n    // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (__DEV__) {\n        console.warn(\"You need to place the ref\");\n      }\n      return cleanup;\n    }\n\n    observer = observeRect(elem, (rect) => {\n      stableOnChange(rect);\n      setRect(rect);\n    });\n\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element, nodeRef, stableOnChange]);\n\n  return rect;\n}\n\n/**\n * @see Docs https://reach.tech/rect#userect\n */\ntype UseRectOptions = {\n  /**\n   * Tells `Rect` to observe the position of the node or not. While observing,\n   * the `children` render prop may call back very quickly (especially while\n   * scrolling) so it can be important for performance to avoid observing when\n   * you don't need to.\n   *\n   * This is typically used for elements that pop over other elements (like a\n   * dropdown menu), so you don't need to observe all the time, only when the\n   * popup is active.\n   *\n   * Pass `true` to observe, `false` to ignore.\n   *\n   * @see Docs https://reach.tech/rect#userect-observe\n   */\n  observe?: boolean;\n  /**\n   * Calls back whenever the `rect` of the element changes.\n   *\n   * @see Docs https://reach.tech/rect#userect-onchange\n   */\n  onChange?: (rect: PRect) => void;\n};\n\ntype PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Exports\n\nexport default Rect;\nexport type { PRect, UseRectOptions, RectProps };\nexport { Rect, useRect };\n"],"names":["Rect","onChange","observe","children","ref","React","rect","useRect","nodeRef","observeOrOptions","deprecated_onChange","isBoolean","isFunction","current","element","setElement","initialRectIsSet","initialRefIsSet","setRect","onChangeRef","stableOnChange","useLayoutEffect","getBoundingClientRect","observer","elem","observeRect","cleanup","unobserve"],"mappings":"mQA2BMA,EAA4B,gBAAGC,IAAAA,aAAUC,QAAAA,gBAAgBC,IAAAA,SACvDC,EAAMC,SAAiC,aAEtCF,EAAS,CAAEC,IAAAA,EAAKE,KADVC,EAAQH,EAAK,CAAEF,QAAAA,EAASD,SAAAA,OAqDvC,SAASM,EACPC,EACAC,EACAC,OAEIR,EACAD,IACAU,YAAUF,GACZP,EAAUO,GAEVP,YAAUO,MAAAA,SAAAA,EAAkBP,wBAC5BD,EAAWQ,MAAAA,SAAAA,EAAkBR,UAE3BW,aAAWF,KACbT,EAAWS,SAuBeL,WAAeG,EAAQK,SAA9CC,OAASC,OACVC,EAAmBX,UAAa,GAChCY,EAAkBZ,UAAa,KACbA,WAA+B,MAAhDC,OAAMY,OACPC,EAAcd,SAAaJ,GAC3BmB,EAAiBf,eAAkB,SAACC,GACtCa,EAAYN,SAAWM,EAAYN,QAAQP,KAC1C,WAGHe,6BAAgB,WACdF,EAAYN,QAAUZ,EAClBO,EAAQK,UAAYC,GACtBC,EAAWP,EAAQK,YAIvBQ,6BAAgB,WACVP,IAAYE,EAAiBH,UAC/BG,EAAiBH,SAAU,EAC3BK,EAAQJ,EAAQQ,4BAEjB,CAACR,IAEJO,6BAAgB,eACVE,EACAC,EAAOV,SAMNG,EAAgBJ,UACnBI,EAAgBJ,SAAU,EAC1BW,EAAOhB,EAAQK,SAGZW,GAOLD,EAAWE,UAAYD,GAAM,SAAClB,GAC5Bc,EAAed,GACfY,EAAQZ,MAGVJ,GAAWqB,EAASrB,UACbwB,GATEA,WAWAA,IACPH,GAAYA,EAASI,eAEtB,CAACzB,EAASY,EAASN,EAASY,IAExBd"}