{"version":3,"file":"rect.cjs.development.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reach.tech/rect\n * @see Source                https://github.com/reach/reach-ui/tree/main/packages/rect\n */\n\nimport * as React from \"react\";\nimport PropTypes from \"prop-types\";\nimport observeRect from \"@reach/observe-rect\";\nimport {\n  isBoolean,\n  isFunction,\n  useIsomorphicLayoutEffect as useLayoutEffect,\n  warning,\n} from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Rect\n *\n * @param props\n */\nconst Rect: React.FC<RectProps> = ({ onChange, observe = true, children }) => {\n  const ref = React.useRef<HTMLElement | null>(null);\n  const rect = useRect(ref, { observe, onChange });\n  return children({ ref, rect });\n};\n\n/**\n * @see Docs https://reach.tech/rect#rect-props\n */\ntype RectProps = UseRectOptions & {\n  /**\n   * A function that calls back to you with a `ref` to place on an element and\n   * the `rect` measurements of the dom node.\n   *\n   * **Note**: On the first render `rect` will be `undefined` because we can't\n   * measure a node that has not yet been rendered. Make sure your code accounts\n   * for this.\n   *\n   * @see Docs https://reach.tech/rect#rect-onchange\n   */\n  children(args: {\n    rect: PRect | null;\n    ref: React.RefObject<any>;\n  }): JSX.Element;\n};\n\nif (__DEV__) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  options?: UseRectOptions\n): null | DOMRect;\n\nfunction useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observe?: UseRectOptions[\"observe\"],\n  onChange?: UseRectOptions[\"onChange\"]\n): null | DOMRect;\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nfunction useRect<T extends Element = HTMLElement>(\n  nodeRef: React.RefObject<T | undefined | null>,\n  observeOrOptions?: boolean | UseRectOptions,\n  deprecated_onChange?: UseRectOptions[\"onChange\"]\n): null | DOMRect {\n  let observe: boolean;\n  let onChange: UseRectOptions[\"onChange\"];\n  if (isBoolean(observeOrOptions)) {\n    observe = observeOrOptions;\n  } else {\n    observe = observeOrOptions?.observe ?? true;\n    onChange = observeOrOptions?.onChange;\n  }\n  if (isFunction(deprecated_onChange)) {\n    onChange = deprecated_onChange;\n  }\n\n  if (__DEV__) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      warning(\n        !isBoolean(observeOrOptions),\n        \"Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\\n\" +\n          \"See https://reach.tech/rect#userect-observe\"\n      );\n    }, [observeOrOptions]);\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      warning(\n        !isFunction(deprecated_onChange),\n        \"Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\\n\" +\n          \"See https://reach.tech/rect#userect-onchange\"\n      );\n    }, [deprecated_onChange]);\n  }\n\n  let [element, setElement] = React.useState(nodeRef.current);\n  let initialRectIsSet = React.useRef(false);\n  let initialRefIsSet = React.useRef(false);\n  let [rect, setRect] = React.useState<DOMRect | null>(null);\n  let onChangeRef = React.useRef(onChange);\n  let stableOnChange = React.useCallback((rect: PRect) => {\n    onChangeRef.current && onChangeRef.current(rect);\n  }, []);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useLayoutEffect(() => {\n    onChangeRef.current = onChange;\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n\n  useLayoutEffect(() => {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n\n  useLayoutEffect(() => {\n    let observer: ReturnType<typeof observeRect>;\n    let elem = element;\n\n    // State initializes before refs are placed, meaning the element state will\n    // be undefined on the first render. We still want the rect on the first\n    // render, so initially we'll use the nodeRef that was passed instead of\n    // state for our measurements.\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n\n    if (!elem) {\n      if (__DEV__) {\n        console.warn(\"You need to place the ref\");\n      }\n      return cleanup;\n    }\n\n    observer = observeRect(elem, (rect) => {\n      stableOnChange(rect);\n      setRect(rect);\n    });\n\n    observe && observer.observe();\n    return cleanup;\n\n    function cleanup() {\n      observer && observer.unobserve();\n    }\n  }, [observe, element, nodeRef, stableOnChange]);\n\n  return rect;\n}\n\n/**\n * @see Docs https://reach.tech/rect#userect\n */\ntype UseRectOptions = {\n  /**\n   * Tells `Rect` to observe the position of the node or not. While observing,\n   * the `children` render prop may call back very quickly (especially while\n   * scrolling) so it can be important for performance to avoid observing when\n   * you don't need to.\n   *\n   * This is typically used for elements that pop over other elements (like a\n   * dropdown menu), so you don't need to observe all the time, only when the\n   * popup is active.\n   *\n   * Pass `true` to observe, `false` to ignore.\n   *\n   * @see Docs https://reach.tech/rect#userect-observe\n   */\n  observe?: boolean;\n  /**\n   * Calls back whenever the `rect` of the element changes.\n   *\n   * @see Docs https://reach.tech/rect#userect-onchange\n   */\n  onChange?: (rect: PRect) => void;\n};\n\ntype PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Exports\n\nexport default Rect;\nexport type { PRect, UseRectOptions, RectProps };\nexport { Rect, useRect };\n"],"names":["Rect","onChange","observe","children","ref","React","rect","useRect","displayName","propTypes","PropTypes","func","isRequired","bool","nodeRef","observeOrOptions","deprecated_onChange","isBoolean","isFunction","warning","current","element","setElement","initialRectIsSet","initialRefIsSet","setRect","onChangeRef","stableOnChange","useLayoutEffect","getBoundingClientRect","observer","elem","console","warn","cleanup","observeRect","unobserve"],"mappings":"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"}